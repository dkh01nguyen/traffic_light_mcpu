\section{Summary}

This project involved the development of a comprehensive Python-based toolset for the simulation and verification of Petri nets. Through the completion of five distinct implementation tasks, the following milestones were achieved:

\begin{itemize}
    \item \textbf{Parsing and Robustness:} Implementation of a fault-tolerant PNML parser and matrix processing unit capable of handling diverse input constraints.
    \item \textbf{Reachability Analysis:} A dual-approach implementation involving Explicit (BFS/DFS) and Symbolic (BDD) algorithms. The results highlighted a clear dichotomy: explicit methods excel in processing speed for small nets, whereas BDDs are required for scalability in high-complexity environments.
    \item \textbf{Deadlock and Optimization:} The deployment of a hybrid verification strategy that successfully identifies deadlocks and optimal firing sequences while maintaining system stability.
\end{itemize}

Overall, the application serves as a practical demonstration of formal methods in software engineering. It reinforces the necessity of adapting algorithmic strategies—specifically choosing between explicit state enumeration and symbolic representation—based on the scale and complexity of the concurrent system being modeled.




% -----------------------------------------------------------------------------
% CHAPTER 2: THEORETICAL BACKGROUND
% -----------------------------------------------------------------------------
\section{THEORETICAL BACKGROUND}

\section{The Microcontroller Unit (MCU)}
The project utilizes the [Specify MCU, e.g., AT89S52/ATmega32]. This section details its architecture, memory organization, I/O ports, Timers, and Interrupt structure.
% (Insert detailed explanation on the chosen MCU, its registers, and how Timer/Interrupts are configured for 1-second counting.)

\section{Interfacing with LCD 16x2}
The LCD 16x2 module based on the HD44780 controller is used for information display.
\begin{itemize}
    \item \textbf{Interface Mode:} 4-bit mode is selected to minimize I/O pin usage.
    \item \textbf{Control Pins:} RS (Register Select), RW (Read/Write), and E (Enable) are utilized to send commands and data.
\end{itemize}
% (Insert explanation on LCD initialization process and common command set.)

\section{Input/Output Peripherals}
\subsection{LED Indicators}
The traffic lights are implemented using high-intensity LEDs. The current limiting resistor ($R$) is calculated by:
\begin{equation}
    R = \frac{V_{CC} - V_{LED}}{I_{LED}}
\end{equation}
With $V_{CC}=5V$, $V_{LED} \approx 2V$, and $I_{LED} = 15mA$, a standard $R=200\Omega$ or $330\Omega$ resistor is selected.

\subsection{Pushbuttons and Debouncing}
The system uses four pull-up configured pushbuttons. Software debouncing (typically 20ms delay) is implemented to ensure reliable signal readings from the mechanical switches.

% -----------------------------------------------------------------------------
% CHAPTER 3: HARDWARE AND SYSTEM DESIGN
% -----------------------------------------------------------------------------
\section{HARDWARE AND SYSTEM DESIGN}

\section{System Block Diagram}
The system is logically divided into three main blocks as shown below:
\begin{figure}[H]
    \centering
    % \includegraphics[width=0.8\textwidth]{block_diagram.png} 
    \caption{System Block Diagram}
    \label{fig:block_diagram}
\end{figure}

\section{Pin Allocation and Interfacing}
\begin{itemize}
    \item \textbf{Port 1 (P1.0 - P1.5):} Outputs for 6 Traffic LEDs (Direction A and B).
    \item \textbf{Port 2 (P2.4 - P2.7 + Control Pins):} 4-bit Data Interface for LCD.
    \item \textbf{Port 3 (P3.0 - P3.3):} Inputs for the 4 Pushbuttons (Input with internal pull-ups enabled).
    \item \textbf{Clock Circuitry:} Crystal Oscillator (11.0592MHz or 12MHz) for MCU timing.
\end{itemize}

\section{Circuit Schematic}
The detailed schematic (simulated in Proteus) shows the connections. (A driving circuit, such as a Transistor array like ULN2003 or simple NPN transistors, should be used if the LED current exceeds the MCU's maximum sink/source current per pin.)
\begin{figure}[H]
    \centering
    % \includegraphics[width=0.9\textwidth]{schematic.png}
    \caption{Circuit Schematic of the Traffic Light Controller}
\end{figure}

% -----------------------------------------------------------------------------
% CHAPTER 4: ALGORITHM AND SOFTWARE IMPLEMENTATION
% -----------------------------------------------------------------------------
\section{ALGORITHM AND SOFTWARE IMPLEMENTATION}

\section{Finite State Machine (FSM) Logic}
The traffic light sequence follows a standard four-state Finite State Machine model:
\begin{enumerate}
    \item \textbf{State 1:} Direction A: GREEN ($T_{Green}$) - Direction B: RED ($T_{Red}$).
    \item \textbf{State 2:} Direction A: YELLOW ($T_{Yellow}$) - Direction B: RED (continued).
    \item \textbf{State 3:} Direction A: RED ($T_{Red}$) - Direction B: GREEN ($T_{Green}$).
    \item \textbf{State 4:} Direction A: RED (continued) - Direction B: YELLOW ($T_{Yellow}$).
\end{enumerate}

\section{Flowchart}
The main routine flowchart details the system's initialization, button scanning, mode checking, and function calls.
\begin{figure}[H]
    \centering
    % \includegraphics[width=0.7\textwidth]{flowchart.png}
    \caption{Main Program Flowchart}
\end{figure}

\section{Timer Calculation}
To achieve a precise 1-second delay using Timer 0 in 16-bit mode with an $F_{osc}$ of 12MHz, the required Timer value is calculated as follows:
$$T_{delay} = (65536 - Value) \times \frac{12}{F_{osc}}$$
For a 1ms interrupt (to count up to 1s), $Value = 65536 - \frac{1ms \times 12MHz}{12} = 64536 = 0xFC18$. The final 1-second counter is then built by accumulating 1000 such 1ms interrupts.

\section{Software Code Snippet (C Language)}
The system is programmed in C using the Keil C IDE.

\begin{lstlisting}[language=C, caption=Main Logic and Variable Definition]
#include <reg51.h>
// Pin definitions (example)
sbit BTN_MODE = P3^0;
// Global Variables
unsigned int T_Green = 25; // Default 25s
unsigned int T_Yellow = 3; // Default 3s
unsigned int T_Red;        // Calculated: T_Red = T_Green + T_Yellow

unsigned char Current_Mode = 0; // 0: Auto, 1: Manual/Warning, 2: Edit

// Function to enforce the safety logic
void calculate_red_time() {
    T_Red = T_Green + T_Yellow;
}

// Timer Interrupt Service Routine (1ms)
void Timer0_ISR() interrupt 1 {
    // Reload for 1ms delay (adjust based on Fosc)
    TH0 = 0xFC;
    TL0 = 0x18; 
    
    // 1-second counter logic...
}

void main() {
    System_Init();
    calculate_red_time();
    while(1) {
        Scan_Buttons();
        switch(Current_Mode) {
            case 0: Run_Auto_Mode(); break;
            case 1: Run_Manual_Mode(); break;
            case 2: Run_Edit_Mode(); break;
        }
        Update_LCD_Display();
    }
}
\end{lstlisting}

% -----------------------------------------------------------------------------
% CHAPTER 5: SIMULATION RESULTS
% -----------------------------------------------------------------------------
\section{SIMULATION RESULTS AND EVALUATION}

\section{Simulation Environment}
The hardware design and system functionality were verified using the Proteus 8 Professional simulation tool.

\section{Achieved Results}
\subsection{Automatic Mode}
The system successfully executed the standard traffic light sequence. When Direction A is Green (25s), Direction B is Red (28s). The LCD displays the countdown for both directions.
\begin{figure}[H]
    \centering
    % \includegraphics[width=0.8\textwidth]{sim_auto.png}
    \caption{Simulation in Automatic Mode: Direction A is Green}
\end{figure}

\subsection{Editing Mode}
The Edit Mode allows the operator to change the $T_{Green}$ and $T_{Yellow}$ values using the UP/DOWN buttons. The system correctly recalculates $T_{Red}$ automatically.
\begin{itemize}
    \item When $T_{Green}$ is changed from 25s to 30s, $T_{Red}$ automatically updates from 28s to 33s.
\end{itemize}

\subsection{Warning Mode}
Activating the Warning mode causes both Yellow lights to flash synchronously at 1Hz, and the LCD displays "WARNING MODE".

\section{Evaluation}
\textbf{Strengths:}
\begin{itemize}
    \item The critical safety logic ($T_{Red} = T_{Green} + T_{Yellow}$) is robustly implemented.
    \item The LCD provides an intuitive and necessary human-machine interface (HMI) for status monitoring.
    \item The FSM structure ensures clear separation and control of traffic phases.
\end{itemize}

\textbf{Limitations:}
\begin{itemize}
    \item The system is based on fixed timing and does not adapt to traffic density.
    \item Lack of a real-time clock (RTC) for time-of-day programming.
\end{itemize}

% -----------------------------------------------------------------------------
% CONCLUSION
% -----------------------------------------------------------------------------
\section*{CONCLUSION AND FUTURE WORK}
\addcontentsline{toc}{chapter}{CONCLUSION AND FUTURE WORK}

\textbf{Conclusion:}
The final project successfully met all design requirements for a flexible four-way traffic light controller. The group gained practical experience in applying microcontroller programming techniques, including Timer/Interrupt handling, and interfacing with key peripherals like LCDs and pushbuttons.

\textbf{Future Work:}
To enhance the system for real-world application, future developments could include:
\begin{enumerate}
    \item Implementing sensor input (e.g., inductive loops or cameras) to dynamically adjust $T_{Green}$ based on real-time traffic flow (Smart Traffic Light).
    \item Integrating a communication module (e.g., UART or ESP8266 Wi-Fi) for remote monitoring and centralized control.
    \item Upgrading the MCU to a 32-bit platform (e.g., STM32) for greater processing power and peripheral options.
\end{enumerate}